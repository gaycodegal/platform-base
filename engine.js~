const TILE_SIZE = 16;

function Screen(){
    this.canvas = document.createElement("canvas");
    this.ctx = this.canvas.getContext("2d");
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.drawlist = [];
}

Screen.prototype.draw = function(){
    this.ctx.clearRect(0,0,this.width, this.height);
    for(let i = 0; i < this.drawlist.length; ++i){
	this.drawlist[i].draw(this.ctx);
    }
};

function BasicMap(json){
    this.tiles = json.tiles;
}

BasicMap.prototype.draw = function(ctx){
    for(let x = 0; x < this.tiles.length; ++ x){
	for(let y = 0; y < this.tiles[0].length; ++ y){
	    if(this.tiles[x][y]){
		ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
	    }
	}
    }
};

function Player(map, stats){
    this.map = map;
    this.x = stats.x;
    this.y = stats.y;
    this.g = stats.gravity;
    this.dx = stats.dx;
    this.dy = stats.dy;
    this.mdx = stats.maxDx;
    this.mdy = stats.maxDy;
    this.cthresh = stats.cornerThreshold;
    this.w = TILE_SIZE;
    this.h = TILE_SIZE;
    this.testing = {nxp:0, nyp:0, nx:0, ny:0};
}

Player.prototype.draw = function(ctx){
    ctx.save();
    ctx.fillStyle = "red";
    ctx.fillRect(this.x, this.y, this.w, this.h);
    ctx.fillStyle = "rgba(0,255,0,0.5)";
    ctx.fillRect(this.testing.nxp, this.testing.ny, this.w, this.h * 2);
    ctx.fillRect(this.testing.nx, this.testing.nyp, this.w * 2, this.h);
    ctx.restore();
};

Player.prototype.step = function(dt){
    let dx = dt * this.dx;
    let dy = dt * this.dy;
    if(dx > this.mdx)
	dx = this.mdx;
    if(dy > this.mdy)
	dy = this.mdy;
    let nx = this.x + dx;
    let ny = this.y + dy;
    let rxp = this.x / TILE_SIZE;
    let ryp = this.y / TILE_SIZE;
    const xp = rxp | 0;
    const yp = ryp | 0;
    rxp -= xp;
    ryp -= yp;
    const nxp = xp + 1;
    const nyp = yp + 1
    this.testing.nxp = nxp * TILE_SIZE;
    this.testing.nyp = nyp * TILE_SIZE;
    this.testing.nx = xp * TILE_SIZE;
    this.testing.ny = yp * TILE_SIZE;
    //possibly limit ryp > thresh to only falsying when rxp > 0.5
    if(this.map.tiles[nxp][yp] || (ryp > this.cthresh && this.map.tiles[nxp][nyp])){
	nx = (nxp - 1) * TILE_SIZE;
    }
    //possibly limit rxp > thresh to only falsying when ryp > 0.5
    if(this.map.tiles[xp][nyp] || (rxp > this.cthresh && this.map.tiles[nxp][nyp])){
	ny = (nyp - 1) * TILE_SIZE;
    }
    this.x = nx;
    this.y = ny;
};

function nextFrame() {
    return new Promise(window.requestAnimationFrame);
}

var KEYS = {};

function onkeydown (e){
    KEYS[e.which] = true;
    console.log(KEYS);
}

function onkeyup (e){
    delete KEYS[e.which];
}

window.addEventListener("keydown", onkeydown);
window.addEventListener("keyup", onkeyup);

